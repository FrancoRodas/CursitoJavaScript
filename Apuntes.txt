En JavaScript, usamos variables para almacenar datos. Hay tres formas principales de declarar variables:

var â†’ Antiguo, no recomendado (tiene problemas de alcance).
let â†’ Recomendado cuando el valor puede cambiar.
const â†’ Recomendado cuando el valor no cambiarÃ¡.
Ejemplo de declaraciÃ³n de variables:
var nombre = "Juan";  // No recomendado
let edad = 25;        // Variable que puede cambiar
const PI = 3.1416;    // Constante, su valor no cambia

2ï¸âƒ£ Tipos de Datos en JavaScript
En JS, los datos pueden tener diferentes tipos. AquÃ­ los mÃ¡s importantes:

Tipo de Dato	DescripciÃ³n	                         Ejemplo

string	        Cadenas de texto	                 "Hola mundo"

number	        NÃºmeros enteros y decimales	         42, 3.14

boolean	        Verdadero o falso	                 true, false

null	        Valor intencionalmente vacÃ­o	         null

undefined	Variable declarada sin valor	         let x;

object	        ColecciÃ³n de datos clave-valor	        { nombre: "Juan", edad: 25 }

array	        Lista de elementos	                [1, 2, 3]

Ejemplo de cada tipo

let texto = "Hola, soy un string";  // String
let numero = 42;                    // Number
let esMayor = true;                  // Boolean
let vacio = null;                     // Null
let sinDefinir;                        // Undefined
let persona = { nombre: "Ana", edad: 30 };  // Object
let numeros = [10, 20, 30];                  // Array

ConversiÃ³n de Tipos (CoerciÃ³n de Datos) en JavaScript
La coerciÃ³n de tipos es el proceso en el que JavaScript convierte automÃ¡ticamente o manualmente un tipo de dato en otro.

Existen dos tipos de coerciÃ³n:

CoerciÃ³n implÃ­cita â†’ JS convierte un tipo automÃ¡ticamente.
CoerciÃ³n explÃ­cita â†’ Nosotros convertimos el tipo de dato manualmente.
Vamos a ver cada una con ejemplos.

1ï¸âƒ£ CoerciÃ³n ImplÃ­cita (AutomÃ¡tica)
Ocurre cuando JavaScript cambia un tipo de dato sin que se lo pidamos directamente.

Ejemplo 1: String + NÃºmero â†’ String

console.log("5" + 3);  
ğŸ“Œ Salida: "53"
ğŸ“Œ ExplicaciÃ³n: Como hay un string y un number, JS convierte el 3 en "3" y luego los concatena.

Ejemplo 2: String - NÃºmero â†’ Number

console.log("10" - 2);  
ğŸ“Œ Salida: 8
ğŸ“Œ ExplicaciÃ³n: A diferencia del +, con el -, JS convierte "10" en 10 (nÃºmero) antes de hacer la operaciÃ³n.

Ejemplo 3: MultiplicaciÃ³n y DivisiÃ³n con Strings

console.log("6" * "3");  
console.log("10" / "2");  
ğŸ“Œ Salida: 18 y 5
ğŸ“Œ ExplicaciÃ³n: Como la multiplicaciÃ³n y divisiÃ³n no tienen sentido con strings, JS convierte "6" y "3" en nÃºmeros antes de operar.

Ejemplo 4: Booleanos convertidos a NÃºmero

console.log(true + 1);  
console.log(false + 5);  
ğŸ“Œ Salida: 2 y 5
ğŸ“Œ ExplicaciÃ³n:

true se convierte en 1, por eso 1 + 1 = 2.
false se convierte en 0, por eso 0 + 5 = 5.

Ejemplo 5: Comparaciones (== vs ===)

console.log("5" == 5);  
console.log("5" === 5);  
ğŸ“Œ Salida: true y false
ğŸ“Œ ExplicaciÃ³n:

== convierte "5" a nÃºmero antes de comparar.
=== compara sin conversiÃ³n (como "5" es string y 5 es nÃºmero, da false).
ğŸ›‘ Â¡Cuidado! La coerciÃ³n implÃ­cita puede llevar a errores si no se entiende bien.

2ï¸âƒ£ CoerciÃ³n ExplÃ­cita (Manual)
Cuando queremos cambiar el tipo de dato nosotros mismos, usamos mÃ©todos como:

Number()
String()
Boolean()
parseInt() / parseFloat()

Ejemplo 1: Convertir String a NÃºmero

let numTexto = "25";
let numReal = Number(numTexto);  // Convierte "25" en 25
console.log(numReal + 5);  // 30

Ejemplo 2: Convertir NÃºmero a String

let numero = 100;
let texto = String(numero);  // Convierte 100 en "100"
console.log(texto + " puntos");  // "100 puntos"

Ejemplo 3: Convertir a Booleano

console.log(Boolean(1));    // true
console.log(Boolean(0));    // false
console.log(Boolean(""));   // false
console.log(Boolean("Hola")); // true
ğŸ“Œ Reglas de conversiÃ³n a Booleano:

0, "" (string vacÃ­o), null, undefined, NaN â†’ false
Cualquier otro valor â†’ true

Ejemplo 4: Convertir con parseInt() y parseFloat()

console.log(parseInt("10.99"));  // 10 (redondea hacia abajo)
console.log(parseFloat("10.99"));  // 10.99 (mantiene decimales)
ğŸ“Œ parseInt() solo toma la parte entera, mientras que parseFloat() conserva los decimales.



ğŸ§® Operadores en JavaScript (ExplicaciÃ³n Detallada)
Los operadores son sÃ­mbolos que nos permiten realizar operaciones matemÃ¡ticas, comparaciones y asignaciones en JavaScript. Se dividen en varias categorÃ­as:

1ï¸âƒ£ Operadores AritmÃ©ticos
Se usan para realizar cÃ¡lculos matemÃ¡ticos.

Operador	DescripciÃ³n	        Ejemplo	        Resultado
+	        Suma	            5 + 2	        7
-	        Resta	            5 -             3
*	        MultiplicaciÃ³n	    5 * 2	        10
/	        DivisiÃ³n	        5 / 2	        2.5
%	        MÃ³dulo (resto)	    5 % 2	        1
**	        Exponente	        5 ** 2	        25

ğŸ“Œ Ejemplo en cÃ³digo:

let a = 10;
let b = 3;

console.log(a + b); // 13
console.log(a - b); // 7
console.log(a * b); // 30
console.log(a / b); // 3.333...
console.log(a % b); // 1  (resto de la divisiÃ³n)
console.log(a ** b); // 1000 (10 elevado a la 3)

2ï¸âƒ£ Operadores de AsignaciÃ³n
Se usan para asignar valores a variables.

Operador	DescripciÃ³n         Ejemplo	   Equivalente a...
=	        AsignaciÃ³n	        x = 5	   -
+=	        Suma y asigna	    x += 5	   x = x + 5
-=	        Resta y asigna	    x -= 5	   x = x - 5
*=	        Multiplica y asigna	x *= 5	   x = x * 5
/=	        Divide y asigna	    x /= 5	   x = x / 5
%=	        Modulo y asigna	    x %= 5	   x = x % 5
**=	        Exponente y asigna	x **= 2	   x = x ** 2
ğŸ“Œ Ejemplo en cÃ³digo:

let x = 10;

x += 5; // x = x + 5 â†’ x = 15
x -= 2; // x = x - 2 â†’ x = 13
x *= 3; // x = x * 3 â†’ x = 39
x /= 3; // x = x / 3 â†’ x = 13
console.log(x); // 13

3ï¸âƒ£ Operadores de ComparaciÃ³n
Sirven para comparar valores y devuelven true o false.

Operador	DescripciÃ³n	                              Ejemplo	     Resultado
==	        Igualdad (compara valor)	              5 == "5"	     true
===	        Igualdad estricta (compara valor y tipo)  5 === "5"	     false
!=	        Diferente (compara valor)	              5 != "5"	     false
!==	        Diferente estricto (compara valor y tipo) 5 !== "5"	     true
>	        Mayor que	                              10 > 5	     true
<	        Menor que	                              10 < 5	     false
>=	        Mayor o igual que	                      10 >= 10	     true
<=	        Menor o igual que	                      10 <= 5	     false
ğŸ“Œ Ejemplo en cÃ³digo:

console.log(5 == "5");  // true (solo compara valores)
console.log(5 === "5"); // false (compara valor y tipo)
console.log(10 != "10"); // false
console.log(10 !== "10"); // true
console.log(10 > 5);  // true
console.log(10 < 5);  // false
console.log(10 >= 10); // true
console.log(10 <= 5);  // false
ğŸš¨ Â¡OJO con == y ===!

5 == "5" da true porque convierte el string a nÃºmero antes de comparar.
5 === "5" da false porque compara tambiÃ©n el tipo de dato.

4ï¸âƒ£ Operadores LÃ³gicos
Se usan para evaluar expresiones lÃ³gicas.

Operador	DescripciÃ³n	    Ejemplo	        Resultado
&&	        AND (y)	        true && false   false
||	                        ||	            OR (o)
!	        NOT (negaciÃ³n)	!true	        false
ğŸ“Œ Ejemplo en cÃ³digo:

let mayor = true;
let tieneDNI = false;

console.log(mayor && tieneDNI); // false (las dos condiciones deben ser true)
console.log(mayor || tieneDNI); // true (basta con que una sea true)
console.log(!mayor); // false (niega el valor de mayor)
ğŸ›‘ Ejemplo real:

let edad = 20;
let tieneLicencia = true;

if (edad >= 18 && tieneLicencia) {
    console.log("Puedes manejar.");
} else {
    console.log("No puedes manejar.");
}
Si edad = 20 y tieneLicencia = true, el mensaje serÃ¡ "Puedes manejar."
Si edad = 16, el mensaje serÃ¡ "No puedes manejar."

5ï¸âƒ£ Operadores de Incremento y Decremento
Se usan para aumentar o disminuir un valor en 1.

Operador	DescripciÃ³n	              Ejemplo	   Resultado
++	        Incremento	              x++	       Aumenta x en 1
--	        Decremento	              x--	       Disminuye x en 1
ğŸ“Œ Ejemplo en cÃ³digo:

let contador = 5;

console.log(contador++); // 5 (primero muestra el valor, luego suma 1)
console.log(contador); // 6 (ahora el valor sÃ­ aumentÃ³)

console.log(++contador); // 7 (suma 1 antes de mostrar el valor)
console.log(contador--); // 7 (muestra el valor, luego resta 1)
console.log(contador); // 6
ğŸš€ Diferencia entre x++ y ++x

x++ â†’ Post-incremento: primero usa el valor, luego lo aumenta.
++x â†’ Pre-incremento: primero aumenta el valor, luego lo usa.

Unidad 3: Control de Flujo en JavaScript
En programaciÃ³n, el control de flujo nos permite decidir quÃ© partes del cÃ³digo se ejecutan y cuÃ¡ntas veces. Esto lo logramos con condicionales, bucles y manejo de errores.

1ï¸âƒ£ Condicionales (if, else if, else y switch)
Los condicionales nos permiten tomar decisiones en el cÃ³digo segÃºn una condiciÃ³n.

ğŸ”¹ 1.1 If - Else If - Else

Si una condiciÃ³n se cumple (true), ejecuta un bloque de cÃ³digo; si no, evalÃºa otras opciones.

Ejemplo: Decidir si hace frÃ­o o calor segÃºn la temperatura
let temperatura = 18;

if (temperatura > 25) {
    console.log("Hace calor, salÃ­ en remera.");
} else if (temperatura >= 15 && temperatura <= 25) {
    console.log("El clima estÃ¡ templado.");
} else {
    console.log("Hace frÃ­o, llevate abrigo.");
}
ğŸ”¹ ExplicaciÃ³n:

Si la temperatura es mayor a 25, se ejecuta el primer bloque.
Si no, pero estÃ¡ entre 15 y 25, se ejecuta el segundo bloque.
Si no cumple ninguna de las anteriores, se ejecuta el else.

ğŸ”¹ 1.2 Switch (Alternativa al if)

switch es Ãºtil cuando hay muchas opciones fijas.

Ejemplo: MenÃº de opciones
let opcion = 2;

switch (opcion) {
    case 1:
        console.log("Elegiste cafÃ©.");
        break;
    case 2:
        console.log("Elegiste tÃ©.");
        break;
    case 3:
        console.log("Elegiste jugo.");
        break;
    default:
        console.log("OpciÃ³n invÃ¡lida.");
}
ğŸ”¹ ExplicaciÃ³n:

Cada case representa un posible valor de opcion.
break detiene el switch para que no siga ejecutando los demÃ¡s case.
default se ejecuta si ninguna opciÃ³n coincide.

2ï¸âƒ£ Bucles (for, while, do while)
Los bucles permiten repetir un bloque de cÃ³digo varias veces.

ğŸ”¹ 2.1 Bucle For (Para repetir un nÃºmero fijo de veces)
El for es ideal cuando sabemos cuÃ¡ntas veces queremos repetir algo.

Ejemplo: Mostrar los nÃºmeros del 1 al 5
for (let i = 1; i <= 5; i++) {
    console.log(i);
}
ğŸ”¹ ExplicaciÃ³n:

let i = 1: inicializa la variable i.
i <= 5: la condiciÃ³n que debe cumplirse para que el bucle siga.
i++: incrementa i en cada iteraciÃ³n.
ğŸ“Œ Salida:
1
2
3
4
5

ğŸ”¹ Â¿QuÃ© es i en un bucle for?
i es solo una variable que usamos como contador en un bucle. La usamos para llevar el control de cuÃ¡ntas veces se repite el cÃ³digo dentro del bucle.

ğŸ”¹ Estructura de un for
Un bucle for tiene tres partes principales:

for (inicializaciÃ³n; condiciÃ³n; incremento) {
    // CÃ³digo que se ejecuta en cada iteraciÃ³n
}
âœ… InicializaciÃ³n: Se ejecuta solo una vez al principio del bucle. AquÃ­ definimos el valor inicial de i (normalmente 0 o 1).
âœ… CondiciÃ³n: Mientras esta condiciÃ³n sea true, el bucle sigue ejecutÃ¡ndose.
âœ… Incremento: Se ejecuta despuÃ©s de cada iteraciÃ³n y modifica el valor de i.

ğŸ”¹ Ejemplo paso a paso
Vamos a analizar este cÃ³digo:

for (let i = 1; i <= 5; i++) {
    console.log("IteraciÃ³n nÃºmero: " + i);
}
ğŸ” ExplicaciÃ³n paso a paso: 1ï¸âƒ£ InicializaciÃ³n: let i = 1; â†’ Se define i con el valor inicial de 1.
2ï¸âƒ£ CondiciÃ³n: i <= 5; â†’ Mientras i sea menor o igual a 5, el bucle sigue ejecutÃ¡ndose.
3ï¸âƒ£ EjecuciÃ³n: console.log("IteraciÃ³n nÃºmero: " + i); â†’ Se imprime el valor de i.
4ï¸âƒ£ Incremento: i++ â†’ i aumenta en 1 despuÃ©s de cada iteraciÃ³n.

ğŸ”½ Salida en la consola:

IteraciÃ³n nÃºmero: 1
IteraciÃ³n nÃºmero: 2
IteraciÃ³n nÃºmero: 3
IteraciÃ³n nÃºmero: 4
IteraciÃ³n nÃºmero: 5

ğŸ”¹ Tipos de incremento
ğŸŸ¢ Incremento de 1 en 1 (mÃ¡s comÃºn):

for (let i = 0; i < 10; i++) {
    console.log(i);
}
ğŸ”¹ i++ es lo mismo que i = i + 1 â†’ Aumenta i en 1 en cada iteraciÃ³n.

ğŸŸ¡ Incremento de mÃ¡s de 1 (por ejemplo, de 2 en 2):

for (let i = 0; i < 10; i += 2) {
    console.log(i);
}
ğŸ”¹ i += 2 significa que i aumenta de 2 en 2.

ğŸ”´ Decremento (bajando en lugar de subir):

for (let i = 10; i >= 0; i--) {
    console.log(i);
}
ğŸ”¹ i-- es lo mismo que i = i - 1, es decir, el contador va bajando.


ğŸ”¹ Ejemplo prÃ¡ctico con tabla de multiplicar

Ahora que entendemos el incremento, veamos cÃ³mo funciona en un ejercicio real:

let numero = parseInt(readline.question("Ingrese un nÃºmero: "));

for (let i = 1; i <= 10; i++) {
    console.log(`${numero} x ${i} = ${numero * i}`);
}

ğŸ”¹ i comienza en 1 y se incrementa hasta 10. Cada vez que aumenta, se multiplica numero * i.

ğŸ”½ Salida si el usuario ingresa 5:

5 x 1 = 5
5 x 2 = 10
5 x 3 = 15
...
5 x 10 = 50

ğŸ”¹ ConclusiÃ³n
ğŸ“Œ i es el contador que usamos en un bucle for para controlar cuÃ¡ntas veces se ejecuta el cÃ³digo.
ğŸ“Œ Siempre inicia en un valor especÃ­fico, tiene una condiciÃ³n para seguir, y se incrementa en cada repeticiÃ³n.
ğŸ“Œ El incremento puede ser i++ (de 1 en 1), i += 2 (de 2 en 2), o incluso i-- (para contar hacia atrÃ¡s).



ğŸ”¹ 2.2 Bucle While (Repite mientras una condiciÃ³n sea verdadera)
while repite un bloque de cÃ³digo hasta que una condiciÃ³n deje de cumplirse.

Ejemplo: Contar del 1 al 5 usando while
let contador = 1;

while (contador <= 5) {
    console.log(contador);
    contador++; // Importante: sin esto serÃ­a un bucle infinito.
}
ğŸ“Œ Salida:
1
2
3
4
5

ğŸ”¹ 2.3 Bucle Do While (Ejecuta al menos una vez)
El do while se ejecuta al menos una vez, incluso si la condiciÃ³n es falsa.

Ejemplo: Pedir un nÃºmero mayor a 10
let numero;
do {
    numero = parseInt(readline.question("Ingrese un nÃºmero mayor a 10: "));
} while (numero <= 10);

console.log(`Ingresaste: ${numero}`);
ğŸ”¹ ExplicaciÃ³n:

Primero ejecuta el cÃ³digo, sin importar si la condiciÃ³n es falsa.
Luego verifica la condiciÃ³n para decidir si repite o no.

3ï¸âƒ£ Control de Bucles (break y continue)
A veces necesitamos interrumpir un bucle antes de que termine (break) o saltar una iteraciÃ³n (continue).

ğŸ”¹ 3.1 Break (Salir de un bucle)
Se usa para detener un bucle cuando se cumple una condiciÃ³n.

Ejemplo: Detener el bucle al encontrar un nÃºmero
for (let i = 1; i <= 10; i++) {
    if (i === 5) {
        console.log("EncontrÃ© el 5, saliendo...");
        break; // Detiene el bucle
    }
    console.log(i);
}
ğŸ“Œ Salida:
1
2
3
4
EncontrÃ© el 5, saliendo...

ğŸ”¹ 3.2 Continue (Saltar una iteraciÃ³n)
Se usa para saltar una iteraciÃ³n especÃ­fica sin detener el bucle.

Ejemplo: Mostrar nÃºmeros del 1 al 5, pero sin el 3

for (let i = 1; i <= 5; i++) {
    if (i === 3) {
        continue; // Salta el nÃºmero 3
    }
    console.log(i);
}
ğŸ“Œ Salida:
1
2
4
5

4ï¸âƒ£ Manejo de Errores (try...catch)
Los errores pueden hacer que el cÃ³digo se detenga. Para evitarlo, usamos try...catch.

Ejemplo: Manejo de error al dividir por 0
try {
    let num1 = 10;
    let num2 = 0;
    if (num2 === 0) {
        throw new Error("No se puede dividir por cero.");
    }
    console.log(num1 / num2);
} catch (error) {
    console.log("Error:", error.message);
}
ğŸ“Œ Salida:
Error: No se puede dividir por cero.
ğŸ”¹ ExplicaciÃ³n:

try ejecuta el cÃ³digo.
Si ocurre un error, catch lo atrapa y evita que el programa se detenga.
throw lanza un error manualmente.
Resumen de la Unidad
âœ… if - else if - else: Para tomar decisiones.
âœ… switch: Para mÃºltiples opciones fijas.
âœ… for: Para repetir algo un nÃºmero determinado de veces.
âœ… while: Para repetir algo mientras una condiciÃ³n sea verdadera.
âœ… do while: Para ejecutar al menos una vez antes de verificar la condiciÃ³n.
âœ… break: Para detener un bucle antes de que termine.
âœ… continue: Para saltar una iteraciÃ³n sin salir del bucle.
âœ… try...catch: Para manejar errores sin que el programa se rompa.

Un bucle anidado es simplemente un bucle dentro de otro bucle. Se usa cuando necesitamos trabajar con estructuras en dos dimensiones, como tablas, patrones de asteriscos, matrices, etc.

ğŸ”¹ Â¿CÃ³mo funciona?
El bucle externo controla la cantidad de veces que se ejecuta el bucle interno.

ğŸ“Œ Ejemplo 1: Imprimir una cuadrÃ­cula de asteriscos (5x5)

js
for (let i = 1; i <= 5; i++) { // Controla las filas
    let linea = "";
    for (let j = 1; j <= 5; j++) { // Controla las columnas
        linea += "* ";
    }
    console.log(linea);
}
âœ… Salida:

markdown
Copiar
Editar
* * * * * 
* * * * * 
* * * * * 
* * * * * 
* * * * * 
ğŸ” ExplicaciÃ³n
El for externo (i) maneja las filas (va de 1 a 5).

El for interno (j) maneja las columnas (va de 1 a 5).

linea += "* " construye cada fila con asteriscos antes de imprimirla.

ğŸ“Œ Ejemplo 2: TriÃ¡ngulo de nÃºmeros
js
for (let i = 1; i <= 5; i++) {
    let linea = "";
    for (let j = 1; j <= i; j++) {
        linea += j + " ";
    }
    console.log(linea);
}
âœ… Salida:

1 
1 2 
1 2 3 
1 2 3 4 
1 2 3 4 5 
ğŸ” ExplicaciÃ³n
El primer for (i) maneja las filas.

El segundo for (j) imprime nÃºmeros del 1 hasta i en cada fila.

ğŸ“Œ Ejemplo 3: Tablas de multiplicar (1 al 5)

for (let i = 1; i <= 5; i++) {
    console.log(`Tabla del ${i}:`);
    for (let j = 1; j <= 10; j++) {
        console.log(`${i} x ${j} = ${i * j}`);
    }
    console.log(""); // Espacio entre tablas
}
âœ… Salida (Ejemplo con i = 2):

Tabla del 2:
2 x 1 = 2
2 x 2 = 4
2 x 3 = 6
...
2 x 10 = 20
ğŸš€ Resumen
Los bucles anidados son Ãºtiles cuando necesitamos estructuras con filas y columnas.

El bucle externo controla las filas o las iteraciones principales.

El bucle interno ejecuta acciones repetidas dentro de cada iteraciÃ³n del externo.

ğŸ”¹ Â¿QuÃ© es un array en JavaScript?
Un array es una estructura de datos que permite almacenar mÃºltiples valores en una sola variable. Se usa para organizar listas de elementos, como nÃºmeros, palabras u objetos.

ğŸ”¹ CÃ³mo crear un array
Podemos crear un array de varias maneras:

js
// Array vacÃ­o
let miArray = [];

// Array con valores
let numeros = [1, 2, 3, 4, 5];

let frutas = ["manzana", "pera", "plÃ¡tano"];
ğŸ”¹ CÃ³mo acceder a elementos de un array
Cada elemento tiene un Ã­ndice, comenzando desde 0.

js

console.log(frutas[0]); // "manzana"
console.log(frutas[2]); // "plÃ¡tano"
ğŸ”¹ MÃ©todos para aÃ±adir elementos

push() â†’ AÃ±ade al final
unshift() â†’ AÃ±ade al inicio

js

frutas.push("naranja");  // ["manzana", "pera", "plÃ¡tano", "naranja"]
frutas.unshift("kiwi"); // ["kiwi", "manzana", "pera", "plÃ¡tano", "naranja"]
ğŸ”¹ MÃ©todos para eliminar elementos

pop() â†’ Elimina el Ãºltimo
shift() â†’ Elimina el primero

js
frutas.pop(); // ["kiwi", "manzana", "pera", "plÃ¡tano"]
frutas.shift(); // ["manzana", "pera", "plÃ¡tano"]

ğŸ”¹ Diferencias entre slice() y splice()
Estos dos mÃ©todos parecen similares, pero tienen usos muy diferentes:

ğŸ“Œ slice() (extrae elementos SIN modificar el array original)
ğŸ“Œ splice() (modifica el array original, eliminando o agregando elementos)

ğŸ”¹ Ejemplo con slice() (No modifica el array original)
js
let numeros = [10, 20, 30, 40, 50];

// Extraemos una parte del array sin modificar el original

let nuevosNumeros = numeros.slice(1, 4); // Desde la posiciÃ³n 1 hasta la 3 (sin incluir la 4)

console.log(numeros);       // [10, 20, 30, 40, 50]  -> Array original intacto
console.log(nuevosNumeros); // [20, 30, 40] -> Nuevo array con los elementos extraÃ­dos
ğŸ“Œ slice(inicio, fin) â†’ Extrae desde inicio hasta fin - 1.

ğŸ”¹ Ejemplo con splice() (Modifica el array original)
js

let colores = ["Rojo", "Azul", "Verde", "Amarillo", "Negro"];

// Eliminamos 2 elementos desde la posiciÃ³n 1 y agregamos "Blanco" y "Morado"
colores.splice(1, 2, "Blanco", "Morado");

console.log(colores); 
// ["Rojo", "Blanco", "Morado", "Amarillo", "Negro"]
ğŸ“Œ splice(posiciÃ³n, cantidad, nuevoElemento1, nuevoElemento2, ...)
ğŸ‘‰ Borra cantidad de elementos y opcionalmente agrega nuevos en esa posiciÃ³n.

ğŸ”¹ Ordenar arrays con .sort()
El mÃ©todo .sort() ordena los elementos de un array alfabÃ©ticamente por defecto. Sin embargo, cuando trabajamos con nÃºmeros, necesitamos pasarle una funciÃ³n de comparaciÃ³n.

ğŸ“Œ Ejemplo 1: Ordenar nÃºmeros de menor a mayor
js

let numeros = [5, 10, 2, 8, 1];

// Ordenar de menor a mayor
numeros.sort((a, b) => a - b);

console.log(numeros); // [1, 2, 5, 8, 10]
ğŸ”¸ ExplicaciÃ³n:

.sort() compara dos elementos (a y b).

Si a - b es negativo, a se coloca antes que b.

Si a - b es positivo, b se coloca antes que a.

Si a - b es cero, quedan en el mismo lugar.

ğŸ“Œ Ejemplo 2: Ordenar palabras alfabÃ©ticamente
js

let palabras = ["manzana", "pera", "uva", "banana"];

palabras.sort();

console.log(palabras); // ["banana", "manzana", "pera", "uva"]
ğŸ”¸ Las palabras se ordenan automÃ¡ticamente en orden alfabÃ©tico.

ğŸ”¹ Filtrar arrays con .filter()
El mÃ©todo .filter() permite crear un nuevo array con los elementos que cumplen cierta condiciÃ³n.

ğŸ“Œ Ejemplo 3: Filtrar nÃºmeros mayores a 10
js

let numeros = [5, 12, 8, 20, 3, 15];

let mayoresA10 = numeros.filter(numero => numero > 10);

console.log(mayoresA10); // [12, 20, 15]
ğŸ”¸ ExplicaciÃ³n:

.filter() recorre el array y mantiene solo los elementos que cumplen la condiciÃ³n numero > 10.

ğŸ“Œ Ejemplo 4: Filtrar palabras por longitud
js

let palabras = ["casa", "elefante", "sol", "mariposa", "pez"];

let palabrasLargas = palabras.filter(palabra => palabra.length > 4);

console.log(palabrasLargas); // ["elefante", "mariposa"]
ğŸ”¸ AquÃ­ filtramos las palabras que tienen mÃ¡s de 4 letras.

ğŸ“Œ Â¿QuÃ© es un objeto en JavaScript?
Un objeto es una estructura que almacena datos en pares clave-valor. Es como una caja donde guardamos informaciÃ³n organizada.

Ejemplo de un objeto simple:

js

let persona = {
    nombre: "Juan",
    edad: 25,
    ciudad: "Madrid"
};

console.log(persona.nombre); // "Juan"
console.log(persona.edad);   // 25
AquÃ­ persona es un objeto con tres propiedades: nombre, edad y ciudad.

1ï¸âƒ£ Crear y acceder a propiedades de un objeto
Puedes acceder a las propiedades de dos maneras:

âœ” Con punto (.)

js

console.log(persona.nombre); // "Juan"
âœ” Con corchetes ([])

js

console.log(persona["edad"]); // 25


2ï¸âƒ£ Modificar propiedades del objeto
Para cambiar el valor de una propiedad en un objeto, simplemente accedemos a ella y asignamos un nuevo valor.

Ejemplo:
js

let persona = {
    nombre: "Juan",
    edad: 25
};

// Modificar la edad
persona.edad = 26;
console.log(persona.edad); // 26

3ï¸âƒ£ Agregar nuevas propiedades al objeto
Puedes agregar propiedades al objeto en cualquier momento.

Ejemplo:
js

persona.direccion = "Calle Falsa 123";
console.log(persona.direccion); // "Calle Falsa 123"

4ï¸âƒ£ Eliminar propiedades
Para eliminar una propiedad de un objeto, usamos el operador delete.

Ejemplo:
js

delete persona.direccion;
console.log(persona.direccion); // undefined

MÃ©todos de objetos
Un mÃ©todo de objeto es simplemente una funciÃ³n que se define dentro de un objeto. Se usa para que el objeto realice alguna acciÃ³n o calcule algÃºn valor basado en sus propiedades. Los mÃ©todos se definen igual que las funciones, pero dentro del objeto.

Ejemplo de un mÃ©todo de objeto:
javascript

let coche = {
    marca: "Lamborghini",
    modelo: "HuracÃ¡n",
    aÃ±o: 2022,
    // MÃ©todo que muestra informaciÃ³n sobre el coche
    mostrarInfo: function() {
        console.log(`Este coche es un ${this.marca} ${this.modelo} del aÃ±o ${this.aÃ±o}.`);
    }
};

// Llamamos al mÃ©todo del objeto
coche.mostrarInfo(); // Esto imprimirÃ¡: Este coche es un Lamborghini HuracÃ¡n del aÃ±o 2022.
En este ejemplo, el objeto coche tiene una propiedad llamada mostrarInfo que es un mÃ©todo. Este mÃ©todo utiliza this para acceder a las propiedades del objeto (marca, modelo, aÃ±o) y las imprime en la consola.

El uso de this
El valor de this en JavaScript hace referencia al objeto que estÃ¡ llamando al mÃ©todo. Es una forma de acceder a las propiedades y mÃ©todos del objeto desde dentro de la propia funciÃ³n.

En el ejemplo anterior:

javascript

mostrarInfo: function() {
    console.log(`Este coche es un ${this.marca} ${this.modelo} del aÃ±o ${this.aÃ±o}.`);
}
this.marca se refiere a la propiedad marca del objeto coche.

this.modelo se refiere a la propiedad modelo del objeto coche.

this.aÃ±o se refiere a la propiedad aÃ±o del objeto coche.

MÃ©todos abreviados con this
En ECMAScript 6 (ES6), podemos usar una forma mÃ¡s corta para escribir los mÃ©todos dentro de un objeto. La funciÃ³n es definida de una manera mÃ¡s compacta:

javascript

let coche = {
    marca: "Lamborghini",
    modelo: "HuracÃ¡n",
    aÃ±o: 2022,
    mostrarInfo() {
        console.log(`Este coche es un ${this.marca} ${this.modelo} del aÃ±o ${this.aÃ±o}.`);
    }
};

coche.mostrarInfo(); // Esto tambiÃ©n imprimirÃ¡: Este coche es un Lamborghini HuracÃ¡n del aÃ±o 2022.

ğŸ”¹ CÃ³mo recorrer un objeto en JavaScript
A diferencia de los arrays, los objetos no tienen Ã­ndices numÃ©ricos, asÃ­ que necesitamos otras formas de recorrer sus propiedades y valores.

ğŸ“Œ Tres mÃ©todos comunes para recorrer un objeto:

for...in â†’ Recorre las claves (propiedades) del objeto.

Object.keys(obj) â†’ Devuelve un array con las claves del objeto.

Object.values(obj) â†’ Devuelve un array con los valores del objeto.

Object.entries(obj) â†’ Devuelve un array con pares [clave, valor].

ğŸ“Œ Ejemplo con for...in
js

let persona = {
    nombre: "Ana",
    edad: 30,
    profesion: "Ingeniera"
};

for (let clave in persona) {
    console.log(`${clave}: ${persona[clave]}`);
}
ğŸ“ Salida en consola:

nombre: Ana  
edad: 30  
profesion: Ingeniera  

ğŸ“Œ Ejemplo con Object.keys()
js

let claves = Object.keys(persona);
console.log(claves); 
ğŸ“ Salida:
["nombre", "edad", "profesion"]

ğŸ“Œ Ejemplo con Object.values()
js

let valores = Object.values(persona);
console.log(valores);
ğŸ“ Salida:
["Ana", 30, "Ingeniera"]

ğŸ“Œ Ejemplo con Object.entries()
js

let entradas = Object.entries(persona);
console.log(entradas);
ğŸ“ Salida:  
js

[
  ["nombre", "Ana"],
  ["edad", 30],
  ["profesion", "Ingeniera"]
]

ğŸ“Œ Estructura de for...in
La sintaxis bÃ¡sica es:

js

for (let variable in objeto) {
    // CÃ³digo que se ejecuta para cada propiedad
}
ğŸ“ ExplicaciÃ³n de cada parte:
1ï¸âƒ£ variable â†’ Representa el nombre de la propiedad del objeto en cada iteraciÃ³n.
2ï¸âƒ£ objeto â†’ Es el objeto que estamos recorriendo.
3ï¸âƒ£ Dentro del bloque {} usamos objeto[variable] para acceder al valor de esa propiedad.

ğŸ“Œ Tu cÃ³digo explicado paso a paso
js

let libro = {
    titulo: "El SeÃ±or de los Anillos",
    autor: "J.R.R. Tolkien",
    aÃ±o: 1954,
}
AquÃ­ tenemos un objeto con tres propiedades:

"titulo" â†’ "El SeÃ±or de los Anillos"

"autor" â†’ "J.R.R. Tolkien"

"aÃ±o" â†’ 1954

ğŸ“Œ Ahora recorremos el objeto con for...in:
js

for (let propiedad in libro) {
    console.log(`${propiedad}: ${libro[propiedad]}`);
}
ğŸ” Â¿QuÃ© pasa en cada vuelta del bucle?

IteraciÃ³n	propiedad toma el valor de:	        libro[propiedad] devuelve:
1Â° vuelta	      "titulo"	                    "El SeÃ±or de los Anillos"
2Â° vuelta	      "autor"	                    "J.R.R. Tolkien"
3Â° vuelta	      "aÃ±o"	                         1954
ğŸ“ Salida en consola:

titulo: El SeÃ±or de los Anillos
autor: J.R.R. Tolkien
aÃ±o: 1954

ğŸ“Œ Â¿Por quÃ© usamos libro[propiedad] en lugar de libro.propiedad?
ğŸ“ Cuando accedemos a un objeto, normalmente usamos punto (.):
js

console.log(libro.titulo); // "El SeÃ±or de los Anillos"
ğŸ”¸ Pero en for...in, la propiedad se guarda como una STRING, por eso usamos [].

ğŸš¨ Si usamos libro.propiedad, JavaScript buscarÃ­a una propiedad llamada propiedad, que no existe.

ğŸ“Œ Ejemplo del error:

js

console.log(libro.propiedad); // âŒ undefined
console.log(libro["titulo"]); // âœ… "El SeÃ±or de los Anillos"
ğŸ“Œ Resumen rÃ¡pido
1ï¸âƒ£ for...in recorre las propiedades (claves) de un objeto.
2ï¸âƒ£ propiedad es una string, por lo que usamos objeto[propiedad] para acceder al valor.
3ï¸âƒ£ Es Ãºtil para recorrer objetos completos sin importar cuÃ¡ntas propiedades tenga.
